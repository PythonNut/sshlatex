#!/bin/bash
# Usage: sshlatex ssh.example.org foo.tex

# For passing some kinds of data, for instance file names, to the remote host,
# we employ the LC_* environment variables. These are automatically transmitted
# by ssh. Yes, this is one of many hacks in this tool.

# Given a LaTeX source file as first argument, outputs a null-delimited list of
# dependencies the file has.
function texdeps {
    perl -nwe '
        for(/\\(?:includegraphics|input|include)(?:\[[^\]]*\])?{([^}]+)}/) {
            for("", qw< .png .jpeg .jpg .tex .bbl >) {
                print "$1$_\0" if -e "$1$_";
            }
        }
    ' "$1"

    bbl="`basename "$1" .tex`.bbl"
    [ -e "$bbl" ] && { echo -n "$bbl"; echo -en "\0"; }
}

# Waits for the file given in the first argument to change.
function waitforfile {
    inotifywait -qq -e close_write "$1"

    # Wait for the file to settle.
    perl -MTime::HiRes=sleep,time,stat -we '
        my $DELAY = 0.05;
        while(1) {
            my $ftime = (stat $ARGV[0])[9];
            if(time() - $ftime < $DELAY) {
                sleep $DELAY;
            } else {
                exit;
            }
        }
    ' "$1"
}

# Cleans up the temporary files (locally and on the remote end).
function cleanup {
    echo -n "Cleaning up... " >&2
    rm "$LC_FILE.time"
    ssh "$host" 'rm -r "$LC_TEMPDIR"'
    echo "done." >&2
}

# Perl program to stream the PDF file to the local host while it is being
# written to. Since pdflatex doesn't simply append to the output, but seeks and
# overwrites earlier parts, this is not completely trivial.
#
# In OUTPUT mode, eekcat repeatedly works through the file in small chunks
# and keeps track of their MD5 checksums. If there are any changes, the
# pertaining blocks are written to STDOUT (with some position information).
#
# In INPUT mode, eekcat reassembles a stream as provided by the OUTPUT mode and
# writes it to a file.
export LC_EEKCAT="$(cat <<'EEKCAT'
#!/usr/bin/perl

use warnings;
use strict;

use Time::HiRes qw< sleep >;
use Digest::MD5 qw< md5   >;

use constant DELAY     => 0.05;  # delay between rereadings
use constant BLOCKSIZE => 2048;  # size of chunks (experimentally determined)

my $file = $ARGV[0];

# Formats data by prefixing its length (as a 32-bit integer in big-endian order).
# To be used in list context, for instance as arguments to `print`.
# The obvious alternative would be to return the concatenated string.
# This would be inefficient. Not that it matters, of course, with our repeated
# rereading. It would be better to use LD_PRELOAD tricks to actually find out
# which parts are rewritten by pdflatex.
sub serialize {
    my $data = shift;
    die "Too long!" if length($data) >= 2**32;
    return pack("N", length $data), $data;
}

# Tries to unmarshal data formatted by `serialize`.
# Returns undef if the indicated length of the data is zero.
# Dies on any reading errors.
sub unserialize {
    my $fh = shift;

    defined(my $num = read $fh, my $len, 4) or die $!;
    return undef if $num == 0;
    die unless $num == 4;

    defined($num = read $fh, my $data, unpack("N", $len)) or die $!;
    die unless $num == unpack("N", $len);

    return $data;
}

if($ARGV[1] eq "OUTPUT") {
    # Disable output buffering.
    # TODO: Check whether this is actually an advantage.
    $|++;

    # Hash of the MD5 checksum of each block.
    # Indexed by the starting positions.
    my %blocks;
    while(1) {
        # Try to open the input file; don't worry if it's not there yet.
        open my $fh, "<", $file or do {
            sleep DELAY;
            next;
        };

        my $pos   = 0;   # current position in the input file
        my $last6 = "";  # the last six bytes read, necessary to detect the ending marker
        while(not eof $fh) {
            my $len = read $fh, my $data, BLOCKSIZE or die $!;

            $last6 = substr($last6 . $data, -6);

            # Since we use a length-zero chunk to signalize EOF to the
            # receiving end, we may not emit a chunk which just happens to be
            # empty.
            next if $len == 0;

            my $hex = md5($data);
            if(not defined $blocks{$pos} or $blocks{$pos} ne $hex) {
                $blocks{$pos} = $hex;
                print serialize($pos), serialize($data);  # stream block to STDOUT
            }

            $pos += $len;
        }

        close $fh or die $!;

        # We stop not when EOF is reached, but when the PDF file is actually
        # fully written. We recognize this by looking for the PDF ending
        # marker. This is a hack; a better way would be to install an
        # appropriate signal handler.
        if($last6 eq "%%EOF\n") {
            print serialize($pos), serialize("");  # signalize EOF
            last;
        }

        sleep DELAY;
    }
} elsif($ARGV[1] eq "INPUT") {
    # Variable to contain the output file handle. We don't open the output file
    # just yet, because we don't want to clobber it while we're still waiting
    # on the first data to trickle in.
    my $fh;

    # We don't deactivate output buffering, since the PDF file can anyway only
    # be viewed when it's fully transmitted.

    while(1) {
        # Read a chunk. Stop if EOF is reached.
        defined(my $pos  = unserialize(\*STDIN)) or last;
        defined(my $data = unserialize(\*STDIN)) or die;

        open $fh, ">", $file or die $! unless defined $fh;
        seek $fh, $pos, 0 or die $!;

        if(length $data == 0) {  # EOF was signalized
            truncate $fh, $pos or die $!;
        } else {
            print $fh $data or die $!;
        }
    }

    close $fh or die $!;
} else {
    die;
}
EEKCAT
)"

host="$1"
export LC_FILE="`basename "$2" .tex`"

echo "Initial upload..." >&2
export LC_TEMPDIR="$(texdeps "$LC_FILE.tex" | xargs -0 tar -cvz "$LC_FILE.tex" | ssh "$host" '
    tempdir="`mktemp -d`"
    cd "$tempdir"

    tar -xz || exit 1  # unpack the source file and its dependencies

    echo "$LC_EEKCAT" > eekcat.pl

    # Extract the LaTeX preamble.
    # It is important that the begin-of-document marker is put into
    # _sshlatex_main.tex instead of _sshlatex_header.tex. Else PDF streaming
    # might start before new content is ready, causing the output file to be
    # clobbered prematurely. (This behaviour seems to be fostered by biblatex.)
    perl -nwe "last if /\\\\begin{document}/; print" "$LC_FILE.tex" > _sshlatex_header.tex

    # Return the path of the working directory to the local host.
    echo "$tempdir"
')"
echo "Done." >&2

# As we uploaded eekcat to the remote host, we don't have to send its
# source code with every further ssh invocation.
export -n LC_EEKCAT

trap cleanup EXIT

is_first_time=1

while :; do
    # Wait for changes in the source file and push them to the remote.
    # Meanwhile, prestart pdflatex with the preamble of the last run.
    {
        if [ "$is_first_time" = "0" ]; then
            waitforfile "$LC_FILE.tex" >&2
            # It's important that only the raw source data is sent to STDOUT.
            # We don't trust inotifywait enough in this regard.
        fi
        echo "Uploading changed source file..." >&2
        date +%s.%N > "$LC_FILE.time"  # for printing statistics
        gzip -9c "$LC_FILE.tex"
    } | ssh "$host" "$(cat <<'EOF'
            cd "$LC_TEMPDIR"

            # Start streaming the output file.
            rm "$LC_FILE.pdf" 2>/dev/null
            perl eekcat.pl "$LC_FILE.pdf" OUTPUT &

            {
                # Use the preamble of the last run.
                echo '\input{_sshlatex_header.tex}'

                # Then wait for the updated main part to trickle in.
                # It's important to store the new preamble in a temporary file,
                # as pdflatex would not be able to read the header file quicker
                # than we'd truncate it.
                gunzip | perl -we '
                    open my $header, ">", "_sshlatex_header-next.tex" or die $!;
                    open my $main,   ">", "_sshlatex_main.tex"        or die $!;

                    my $fh = $header;
                    while(<>) {
                        $fh = $main if /\\begin{document}/;
                        print $fh $_ or die $!;
                    }
                '
                echo '\input{_sshlatex_main.tex}'
            } | pdflatex -jobname "$LC_FILE" >&2

            mv _sshlatex_header-next.tex _sshlatex_header.tex
EOF
    )" | perl -we "$LC_EEKCAT" "$LC_FILE.pdf" INPUT || exit

    echo -n "*** Elapsed time: " >&2
    perl -we "printf '%.2f seconds', $(date +%s.%N) - $(cat "$LC_FILE.time")" >&2
    echo >&2
    echo >&2
    beepy &>/dev/null &

    sleep 0.05
    is_first_time=0
done
