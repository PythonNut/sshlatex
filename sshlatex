#!/bin/bash
# Usage: sshlatex ssh.example.org foo.tex

# For passing some kinds of data, for instance file names, to the remote host,
# we employ the LC_* environment variables. These are automatically transmitted
# by ssh. Yes, this is one of many hacks in this tool.

# Recall that using "echo -n ..." is not necessarily safe (robust), if "..."
# happens to look like an option. This function is a safe substitute. It's only
# necessary because echo doesn't respect the usual convention of two dashes (--)
# separating options from other arguments.
function safeechon {
    perl -we 'print $ARGV[0]' -- "$1"
}

# Given a LaTeX source file as first argument, outputs a null-delimited list of
# dependencies the file has. The file itself is included as well.
function texdeps {
    safeechon "$1"
    echo -en "\0"

    perl -we '
        my @files = ($ARGV[0]);

        # We do not use the usual while(<>) idiom (and @ARGV) because that is
        # not special-character-safe. The safe substitute operator <<>>
        # is only available from Perl 5.22 on, which we do not want to depend on.
        while(@files) {
            open my $fh, "<", shift(@files) or next;
            while(defined(my $line = <$fh>)) {
                for my $dep ($line =~ /\\(?:includegraphics|input|include|documentclass)(?:\[[^\]]*\])?{([^}]+)}/) {
                    for("", qw< .png .jpeg .jpg .pdf .tex .cls .bbl >) {
                        if(-e "$dep$_") {
                            print "$dep$_\0";

                            # Recursively search included LaTeX source files.
                            push @files, "$dep$_" if "$dep$_" =~ /\.(?:tex|cls)$/;
                        }
                    }
                }
            }
            close $fh or die $!;
        }
    ' -- "$1"

    bbl="`basename -- "$1" .tex`.bbl"
    [ -e "$bbl" ] && { safeechon "$bbl"; echo -en "\0"; }
}

# Waits for the file given in the first argument (and its dependencies) to
# change.
function waitforfiles {
    texdeps "$1" | HAVE_INOTIFYWAIT="`which inotifywait`" xargs -0 perl -MTime::HiRes=sleep,time,stat -we '
        my $DELAY = 0.05;

        if($ENV{HAVE_INOTIFYWAIT}) {
            system qw< inotifywait -qq -e close_write -- >, @ARGV;
        } else {
            print STDERR "*** inotifywait not found; falling back to polling...\n";
            my $start = time();
            WAIT_FOR_CHANGES: while(1) {
                sleep $DELAY;
                for my $file (@ARGV) {
                    my $ftime = (stat $file)[9];
                    next unless $ftime;  # if file vanished
                    if($ftime > $start) {
                        last WAIT_FOR_CHANGES;
                    }
                }
            }
        }

        # Wait for the files to settle.
        sleep $DELAY;

        LOOP: while(1) {
            for my $file (@ARGV) {
                my $ftime = (stat $file)[9];
                next unless $ftime;
                if(time() - $ftime < $DELAY) {
                    sleep $DELAY;
                    next LOOP;
                }
            }
            last;
        }
    '
}

# Cleans up the temporary files (locally and on the remote end).
function cleanup {
    echo -n "*** Cleaning up... " >&2
    rm -- "$LC_FILE.time" "$LC_FILE.new.pdf" 2>/dev/null
    ssh "$host" 'rm -r "$LC_TEMPDIR"'
    echo "done." >&2
}

# Perl program to stream the PDF file to the local host while it is being
# written to. Since pdflatex doesn't simply append to the output, but seeks and
# overwrites earlier parts, this is not completely trivial.
#
# In OUTPUT mode, eekcat repeatedly works through the file in small chunks
# and keeps track of their MD5 checksums. If there are any changes, the
# pertaining blocks are written to STDOUT (with some position information).
#
# In INPUT mode, eekcat reassembles a stream as provided by the OUTPUT mode and
# writes it to a file.
export LC_EEKCAT="$(cat <<'EEKCAT'
#!/usr/bin/perl

use warnings;
use strict;

use Time::HiRes qw< sleep >;
use Digest::MD5 qw< md5   >;

use constant DELAY     => 0.05;  # delay between rereadings
use constant BLOCKSIZE => 2048;  # size of chunks (experimentally determined)

my $file = $ARGV[0];

# Formats data by prefixing its length (as a 32-bit integer in big-endian order).
# To be used in list context, for instance as arguments to `print`.
# The obvious alternative would be to return the concatenated string.
# This would be inefficient. Not that it matters, of course, with our repeated
# rereading. It would be better to use LD_PRELOAD tricks to actually find out
# which parts are rewritten by pdflatex.
sub serialize {
    my $data = shift;
    die "Too long!" if length($data) >= 2**32;
    return pack("N", length $data), $data;
}

# Tries to unmarshal data formatted by `serialize`.
# Returns undef if the indicated length of the data is zero.
# Dies on any reading errors.
sub unserialize {
    my $fh = shift;

    defined(my $num = read $fh, my $len, 4) or die $!;
    return undef if $num == 0;
    die unless $num == 4;

    defined($num = read $fh, my $data, unpack("N", $len)) or die $!;
    die unless $num == unpack("N", $len);

    return $data;
}

if($ARGV[1] eq "OUTPUT") {
    require IO::Handle;  # not "use" because we need it only in this branch

    # Hash of the MD5 checksum of each block.
    # Indexed by the starting positions.
    my %blocks;
    my $stop_after_this_run;
    my $input_file_is_complete;

    # Subscribe to the file-has-settled notification.
    $SIG{USR1} = sub { $input_file_is_complete = 1 };

    while(1) {
        # Try to open the input file; don't worry if it's not there yet.
        open my $fh, "<", $file or do {
            last if $input_file_is_complete;  # quit if we're signalized to do so
            sleep DELAY;
            next;
        };

        my $pos   = 0;  # current position in the input file
        my $len;        # length of most recently read block
        while(not eof $fh) {
            $len = read $fh, my $data, BLOCKSIZE or die $!;

            # Since we use a length-zero chunk to signalize EOF to the
            # receiving end, we may not emit a chunk which just happens to be
            # empty.
            next if $len == 0;

            # Don't bother with partial chunks if we are not in the last run.
            # The usual reason for a partial chunk is that it is the last chunk
            # of the file, which we expect to change anyway since the file will
            # likely grow.
            next if $len < BLOCKSIZE and not $stop_after_this_run;

            my $hex = md5($data);
            if(not defined $blocks{$pos} or $blocks{$pos} ne $hex) {
                $blocks{$pos} = $hex;
                print serialize($pos), serialize($data) or die $!;  # stream block to STDOUT
            }
        } continue {
            $pos += $len;
        }

        close $fh or die $!;

        if($stop_after_this_run) {
            print serialize($pos), serialize("") or die $!;  # signalize EOF
            last;
        }

        # We stop not when EOF is reached, but when the PDF file is actually
        # fully written. We rely on being sent the SIGUSR1 signal to detect
        # this.
        if($input_file_is_complete) {
            $stop_after_this_run++;
            next;  # we may skip the DELAY, since the file is fully written
        }

        STDOUT->flush() or die $!;
        sleep DELAY;
    }

    STDOUT->flush() or die $!;
} elsif($ARGV[1] eq "INPUT") {
    open my $fh, ">", $file or die $!;

    # We don't deactivate output buffering, since the PDF file can anyway only
    # be viewed when it's fully transmitted.

    while(1) {
        # Read a chunk. Stop if EOF is reached.
        defined(my $pos  = unserialize(\*STDIN)) or last;
        defined(my $data = unserialize(\*STDIN)) or die;

        seek $fh, $pos, 0 or die $!;

        if(length $data == 0) {  # EOF was signalized
            truncate $fh, $pos or die $!;
        } else {
            print $fh $data or die $!;
        }
    }

    close $fh or die $!;
} else {
    die;
}
EEKCAT
)"

host="$1"
export LC_FILE="`basename -- "$2" .tex`"

[ -n "$1" -a -n "$2" ] || {
    echo "Usage: sshlatex ssh.example.org foo.tex" >&2
    exit 1
}

[ -e "$LC_FILE.tex" ] || {
    echo "*** Error: LaTeX source file not found. \"$LC_FILE.tex\"" >&2
    exit 1
}

# Invariant: The source files on the server are always as least as
# new as recorded in $time_of_remote_files (as measured in local time).
time_of_remote_files="`date +%s.%N`"

echo "*** Initial upload..." >&2
export LC_TEMPDIR="$(texdeps "$LC_FILE.tex" | xargs -0 tar -cvz -- | ssh "$host" '
    tempdir="`mktemp -d`"
    cd "$tempdir"

    tar -xz || exit 1  # unpack the source file and its dependencies

    echo "$LC_EEKCAT" > eekcat.pl

    # Extract the LaTeX preamble.
    # It is important that the begin-of-document marker is put into
    # _sshlatex_header.tex instead of _sshlatex_main.tex. This way pdflatex
    # will do more initialization while we are waiting for the changed source
    # to arrive.
    perl -nwe "print; last if /\\\\begin{document}/" -- "$LC_FILE.tex" > _sshlatex_header.tex

    # Return the path of the working directory to the local host.
    echo "$tempdir"
')"
if [ -z "$LC_TEMPDIR" ]; then
    echo "Didn't get a proper server response; aborting." >&2
    exit 1
fi
echo "Done." >&2
echo >&2

# As we uploaded eekcat to the remote host, we don't have to send its
# source code with every further ssh invocation.
export -n LC_EEKCAT

trap cleanup EXIT

is_first_time=1

while :; do
    [ -e "$LC_FILE.tex" ] || {
        echo "*** Error: The LaTeX source file vanished. \"$LC_FILE.tex\"" >&2
        exit 1
    }

    # Wait for changes in the source file and push them to the remote.
    # Meanwhile, prestart pdflatex with the preamble of the previous run.
    {
        if [ "$is_first_time" = "0" ]; then
            waitforfiles "$LC_FILE.tex" >&2
            # It's important that only the raw source data is sent to STDOUT.
            # We don't trust inotifywait enough in this regard.
        fi
        echo "*** Uploading source files..." >&2
        touch -- "$LC_FILE.new.pdf"  # to ensure that the logic for withholding
                                     # the pdflatex log output (triggered by
                                     # creating $LC_FILE.time) doesn't abort early
        date +%s.%N > "$LC_FILE.time"  # for printing statistics,
                                       # for updating $time_of_remote_files, and
                                       # for triggering the un-withholding of
                                       # the pdflatex log output
        texdeps "$LC_FILE.tex" | xargs -0 tar -N "@$time_of_remote_files" -cvz --
    } | ssh "$host" "$(cat <<'EOF'
            cd "$LC_TEMPDIR"

            # Start streaming the output file.
            rm -- "$LC_FILE.pdf" 2>/dev/null
            perl eekcat.pl "$LC_FILE.pdf" OUTPUT &

            echo "*** Ready on the remote side..." >&2

            {
                # Use the preamble of the previous run.
                echo '\input{_sshlatex_header.tex}'

                # Then wait for the updated main part to trickle in.
                # It's important to store the new preamble in a temporary file,
                # as pdflatex would not be able to read the header file quicker
                # than we'd truncate it.
                tar -xz || exit 1
                perl -we '
                    open my $header, ">", "_sshlatex_header-next.tex" or die $!;
                    open my $main,   ">", "_sshlatex_main.tex"        or die $!;

                    my $fh = $header;
                    while(<>) {
                        print $fh $_ or die $!;
                        $fh = $main if /\\begin{document}/;
                    }
                ' -- "$LC_FILE.tex"

                date +%s.%N > _sshlatex_compilation.time

                # Check that the new preamble equals the preamble with which
                # we've already initialized pdflatex. If not, abort pdflatex by
                # sending the "x" command and rerun.
                if cmp -s _sshlatex_header.tex _sshlatex_header-next.tex >/dev/null; then
                    echo '\input{_sshlatex_main.tex}'
                else
                    echo "*** Preamble change detected; aborting LaTeX and rerunning." >&2
                    touch _sshlatex_redo
                    echo x
                fi
            } | pdflatex -jobname "$LC_FILE" >&2
            exitstatus="$?"

            mv _sshlatex_header-next.tex _sshlatex_header.tex

            if [ -e _sshlatex_redo ]; then
                rm _sshlatex_redo
                echo '\input{_sshlatex_header.tex}\input{_sshlatex_main.tex}' | pdflatex -jobname "$LC_FILE" >&2
                exitstatus="$?"
            fi

            # Signalize completion of the output file to eekcat
            kill -USR1 %1
            perl -we "printf \"*** LaTeX compilation time: %.2f seconds\\n\", $(date +%s.%N) - $(cat _sshlatex_compilation.time)" >&2
            exit "$exitstatus"
EOF
    )" 2> >(
        # This redirection is because we do not want to see the status messages
        # from pdflatex right away (they clutter the screen, in particular they
        # clutter possible error messages from the previous run). We only want
        # to see them when a changed source file was uploaded.
        perl -MTime::HiRes -we '
            my @buf;

            $|++;
            print scalar <>;  # output first line ("Ready on the remote side") immediately

            # Buffer the other status lines of pdflatex until we are uploading
            # the changed source file, to not clutter the console.
            while(<>) {
                push @buf, $_;
                last if -e "$ENV{LC_FILE}.time";  # upload has started
            }

            # If sshlatex is aborted with ^C, we do not want to see the (no
            # longer relevant) status messages from the current run of pdflatex
            # (already initialized with the preamble).
            sleep 0.05;  # allow some time for the cleanup function to
                         # unlink $ENV{LC_FILE}.new.pdf
            exit unless -e "$ENV{LC_FILE}.new.pdf";
            # Should the cleanup function take longer than 0.05 seconds,
            # we will accidentally print the status messages even though they
            # really should be suppresed. That is not such a big deal.

            print @buf;
            print while <>;
        ' >&2
    ) | perl -we "$LC_EEKCAT" -- "$LC_FILE.new.pdf" INPUT || exit

    if [ "${PIPESTATUS[-2]}" = "0" ]; then
        mv -- "$LC_FILE.new.pdf" "$LC_FILE.pdf" 2>/dev/null
    else
        echo "*** An error occured." >&2
    fi

    time_of_remote_files="`cat -- "$LC_FILE.time"`"

    echo -n "*** Total elapsed time:     " >&2
    perl -we "printf '%.2f seconds', $(date +%s.%N) - $time_of_remote_files" >&2
    echo >&2
    echo >&2
    beepy &>/dev/null &

    rm -- "$LC_FILE.time" 2>/dev/null
    # is used to trigger un-withholding of pdflatex log output, so has to be reset

    sleep 0.05
    is_first_time=0
done


# Ideas for future enhancements:
# * Use deduplication to more efficiently stream the PDF file
# * Opportunistically run LaTeX up to approximately the point where the
#   previous change occured
